diff --git a/Makefile b/Makefile
index 2373041..5f09303 100644
--- a/Makefile
+++ b/Makefile
@@ -9,8 +9,8 @@
 #
 # User supplied files
 #
-U_C_SRC = clock.c klibc.c pcbs.c queues.c scheduler.c sio.c stacks.c syscalls.c system.c ulibc.c users.c 
-U_C_OBJ = clock.o klibc.o pcbs.o queues.o scheduler.o sio.o stacks.o syscalls.o system.o ulibc.o users.o
+U_C_SRC = clock.c klibc.c pcbs.c queues.c scheduler.c sio.c stacks.c syscalls.c system.c ulibc.c users.c #serial.c paging.c physical.c
+U_C_OBJ = clock.o klibc.o pcbs.o queues.o scheduler.o sio.o stacks.o syscalls.o system.o ulibc.o users.o #serial.o paging.o physical.o 
 U_S_SRC = klibs.S ulibs.S
 U_S_OBJ = klibs.o ulibs.o
 U_LIBS	=
@@ -122,10 +122,10 @@ prog.out: $(OBJECTS)
 	$(LD) $(LDFLAGS) -o prog.out $(OBJECTS)
 
 prog.o:	$(OBJECTS)
-	$(LD) $(LDFLAGS) -o prog.o -Ttext 0x10000 $(OBJECTS) $(U_LIBS)
+	$(LD) $(LDFLAGS) -o prog.o $(OBJECTS) $(U_LIBS)
 
 prog.b:	prog.o
-	$(LD) $(LDFLAGS) -o prog.b -s --oformat binary -Ttext 0x10000 prog.o
+	$(LD) $(LDFLAGS) -o prog.b -s --oformat binary prog.o
 
 #
 # Targets for copying bootable image onto boot devices
diff --git a/defs.h b/defs.h
index d206abb..0370b69 100644
--- a/defs.h
+++ b/defs.h
@@ -36,6 +36,11 @@
 /*
 ** Types
 */
+typedef int int32;
+typedef unsigned int uint32;
+
+typedef char int8;
+typedef unsigned char uint8;
 
 /*
 ** Globals
diff --git a/linker.ld b/linker.ld
index 598860a..da87183 100644
--- a/linker.ld
+++ b/linker.ld
@@ -1,8 +1,8 @@
-ENTRY (loader)
+ENTRY (_start)
 
 SECTIONS {
-	virt = 0xC0100000;
-	phys = 0x00100000;
+	virt = 0x0010000;/*0xC0100000;*/
+	phys = 0x0010000;
 	
 	.text virt : AT(phys) {
 		code = .;
@@ -24,10 +24,12 @@ SECTIONS {
 
 	.bss ALIGN(0x1000) : AT(phys + (bss - code)) {
 		bss = .;
+		__bss_start = .;
 		sbss = .;
 		*(COMMON)
 		*(.bss)
 		ebss = .;
+		_end = .;
 		KERNEL_END = .;
 	}
 }
diff --git a/memory/.paging.c.swp b/memory/.paging.c.swp
deleted file mode 100644
index f6db3e5..0000000
Binary files a/memory/.paging.c.swp and /dev/null differ
diff --git a/memory/defs.h b/memory/defs.h
deleted file mode 100644
index 14a9fc3..0000000
--- a/memory/defs.h
+++ /dev/null
@@ -1,10 +0,0 @@
-#ifndef __DEFS__H__
-#define __DEFS__H__
-
-typedef int int32;
-typedef unsigned int uint32;
-
-typedef char int8;
-typedef unsigned char uint8;
-
-#endif
diff --git a/memory/kmalloc.c b/memory/kmalloc.c
deleted file mode 100644
index dc001b9..0000000
--- a/memory/kmalloc.c
+++ /dev/null
@@ -1,347 +0,0 @@
-#include "kmalloc.h"
-#include "../serial.h"
-#include "paging.h"
-#include "physical.h"
-
-typedef struct LinkedNode
-{
-	uint32 size; // Size must be first!
-	struct LinkedNode* next;
-	struct LinkedNode* prev;
-} linked_node_t;
-
-#define HEADER_SIZE 4
-
-typedef struct Heap
-{
-	void* start_address;
-	void* end_address;
-	void* max_address;
-	linked_node_t* start_node;
-} heap_t;
-
-heap_t kernel_heap;
-
-// 256 MB of Kernel Heap Space
-#define HEAP_START_LOCATION 0xD0000000
-#define HEAP_MAX_LOCATION   0xE0000000
-#define HEAP_INITIAL_PAGES 2
-
-void __kmem_init_kmalloc()
-{
-	kernel_heap.start_address = (void*)HEAP_START_LOCATION;
-	kernel_heap.max_address = (void*)HEAP_MAX_LOCATION;
-
-	void* start_address = (void*)HEAP_START_LOCATION;
-	int32 i = 0;
-	for (; i < HEAP_INITIAL_PAGES; ++i)
-	{
-		get_page(start_address, (page_dir_t*)page_directory);
-		start_address += 4096;
-	}
-
-	kernel_heap.end_address = start_address;
-	kernel_heap.start_node = (linked_node_t*)HEAP_START_LOCATION;
-
-	kernel_heap.start_node->size = HEAP_INITIAL_PAGES * 4096 - HEADER_SIZE;
-	kernel_heap.start_node->next = 0;
-	kernel_heap.start_node->prev = 0;
-
-	serial_printf("Start address: %X\n", kernel_heap.start_address);
-	serial_printf("End address:   %X\n", kernel_heap.end_address);
-	serial_printf("Max address:   %X\n", kernel_heap.max_address);
-	serial_printf("Node Start:    %X\n", kernel_heap.start_node);
-	serial_printf("Node next:     %X\n", kernel_heap.start_node->next);
-	serial_printf("Node prev:     %X\n", kernel_heap.start_node->prev);
-	serial_printf("Node size:     %d\n", sizeof(linked_node_t));
-}
-
-void* __kmalloc(uint32 size)
-{
-	serial_string("----Allocating----\n");
-	serial_printf("Input size: %d\n", size);
-	// When we add it back to the free list, we need at least
-	// this many bytes
-	if (size < sizeof(linked_node_t) - HEADER_SIZE)
-	{
-		size = sizeof(linked_node_t) - HEADER_SIZE;
-		serial_printf("New size: %d\n", size);
-	}
-
-	// Make it word aligned
-	if (size % 4 != 0)
-	{
-		serial_printf("Aligning size: %d\n", (size % 4));
-		size += 4 - (size % 4);
-		serial_printf("Aligned size: %d\n", size);
-	}
-
-	// Check the nodes for the correct size
-	linked_node_t* current_node = kernel_heap.start_node;
-	while (current_node->next != 0 && current_node->size <= size)
-	{
-		current_node = current_node->next;
-	}
-
-	serial_printf("Node found? %X\n", current_node);
-
-	// We couldn't find a node of sufficient size
-	// so ask for a page
-	if (current_node->next == 0 && current_node->size < size)
-	{
-		uint32 num_pages = (size - current_node->size) / 4096 + 1;
-		serial_printf("No node found, allocating %d pages\n", num_pages);
-		uint32 i = 0;
-		for (; i < num_pages; ++i)
-		{
-			if (kernel_heap.end_address > kernel_heap.max_address)
-			{
-				serial_string("Kernel heap size limit reached!\n");
-				for (;;) { asm("hlt"); }
-			}
-			
-			// Add a new page to the end of our heap
-			__virt_map_page(__phys_get_free_4k(), kernel_heap.end_address);
-			kernel_heap.end_address += 4096;
-		}
-
-		// Expand the node
-		current_node->size = kernel_heap.end_address - (uint32)current_node - HEADER_SIZE;
-
-		serial_printf("Current  node addr: %X\n", current_node);
-	}
-
-	serial_printf("Current  node size: %d\n", current_node->size);
-
-	// Need to setup the next node
-	if (((uint32)current_node + HEADER_SIZE + size + sizeof(linked_node_t)) >= kernel_heap.end_address)
-	{
-		// We need more space, allocate 1 more page
-		get_page(kernel_heap.end_address, (page_dir_t*)page_directory);
-		kernel_heap.end_address += 4096;
-
-		if (kernel_heap.end_address > kernel_heap.max_address)
-		{
-				serial_string("Kernel heap size limit reached!\n");
-				for (;;) { asm("hlt"); }
-		}
-	}
-
-	// Allocate the next node
-	linked_node_t* next_node = (linked_node_t*)((uint32)current_node + size + HEADER_SIZE);
-
-	if (current_node == kernel_heap.start_node)
-	{
-		serial_string("Next node is head node\n");
-		kernel_heap.start_node = next_node;
-		next_node->prev = 0;
-		next_node->next = current_node->next;
-	} else {
-		serial_string("Next node is a middle node\n");
-		next_node->next = current_node->next;
-		next_node->prev = current_node->prev;
-	}
-
-	// Setup next_node's size
-	if (current_node->next == 0)
-	{
-		next_node->size = kernel_heap.end_address - (uint32)next_node - HEADER_SIZE;
-	} else {
-		next_node->size = (uint32)current_node->next - (uint32)next_node - HEADER_SIZE;
-	}
-
-	serial_printf("Next node size: %d\n", next_node->size);
-
-	serial_printf("Returning address: %X\n", (uint32)current_node + HEADER_SIZE);
-
-	serial_string("----End Allocating----\n");
-	current_node->size = size;
-	// Give them the address
-	return (void *)((uint32)current_node + HEADER_SIZE);
-}
-
-/*
-void* realloc(void* address, uint32 new_size)
-{
-}
-*/
-
-/*
-void* kcalloc(void)
-{
-}
-*/
-
-void panic(const char const* message)
-{
-	serial_string("PANIC!\n");
-	serial_string(message);
-	for (;;) { asm("hlt"); }
-}
-
-int list_size()
-{
-	int size = 0;
-	linked_node_t* node = kernel_heap.start_node;
-	while (node != 0)
-	{
-		node = node->next;
-		++size;
-	}
-
-	return size;
-}
-
-void __kmem_kmalloc_tests()
-{
-	serial_string(".---- Start of kmalloc() tests ----.\n");
-	serial_string("|If all is working correctly there |\n");
-	serial_string("|should be an 'All Tests Passed'   |\n");
-	serial_string("|message                           |\n");
-	serial_string("'----------------------------------'\n");
-	// This function makes sure the kmalloc routines are working correctly
-	
-	// Test 1 - Assumes that nothing has been allocated yet, calls kmalloc() and then kfree()
-	// In free it's the code path:
-	//  if (free_node < current_node)
-	//      if ((uint32)free_node + free_node->size + HEADER_SIZE) == current_node)
-	serial_string("========Test 1========\n");
-	void* ptr = kmalloc(10);
-	if (ptr != 0xC0000004) { panic("Bad address returned from kmalloc()\n"); }
-	if (kernel_heap.start_node != 0xC0000010) { panic("Wrong address for next node\n"); }
-	if (kernel_heap.start_node->size != (8192 - 12 - 2*HEADER_SIZE)) { panic("Next node has a bad size!\n"); }
-	if (kernel_heap.start_node->next != 0) { panic("Next node is not 0!\n"); }
-	if (kernel_heap.start_node->prev != 0) { panic("Prev node is not 0!\n"); }
-	kfree(ptr);
-	if (kernel_heap.start_node != 0xC0000000) { panic("Test 1 - kfree() messed up\n"); }
-	if (kernel_heap.start_node->size != (8192 -  HEADER_SIZE)) { panic("Free'd node has a bad size!\n"); }
-	if (kernel_heap.start_node->next != 0) { panic("Free'd next node is not 0!\n"); }
-	if (kernel_heap.start_node->prev != 0) { panic("Free'd prev node is not 0!\n"); }
-
-	// Test 2 - Allocate three things and free the first, tests the code path in free
-	// if (free_node < current_node)
-	//    else - Can't combine 
-	serial_string("========Test 2========\n");
-	ptr  = kmalloc(10);
-	void* ptr2 = kmalloc(10);
-	void* ptr3 = kmalloc(10);
-
-	serial_string("PTR1\n");
-	kfree(ptr);
-	serial_string("PTR3\n");
-	kfree(ptr3);
-	serial_string("PTR2\n");
-	kfree(ptr2);
-
-	serial_printf("Number of Heap nodes: %d\n", list_size());
-	
-	serial_string("========Test 3========\n");
-	ptr = kmalloc(10);
-	
-
-	serial_string("---- All Tests Passed ----\n");
-}
-
-void __kfree(void* address)
-{
-	serial_string("----Free----\n");
-	// Figure out where this node goes
-	linked_node_t* free_node = (linked_node_t*)((uint32)address - HEADER_SIZE);
-
-	serial_printf("Freeing address: %X\n", free_node);
-
-	// Check to see if it's replacing the head node
-	linked_node_t* current_node = kernel_heap.start_node;
-	if (free_node < current_node) // They shouldn't ever be equal
-	{
-		serial_printf("Current node: %X\n", current_node);
-		serial_printf("Current node size: %d\n", current_node->size);
-		serial_printf("Free_node size   : %d\n", free_node->size);
-		serial_string("Free_node before head node\n");
-		// First check to see if they can be combined
-		if (((uint32)free_node + free_node->size + HEADER_SIZE) == current_node)
-		{
-			serial_string("Can combine free_node and start_node\n");
-			kernel_heap.start_node = free_node;
-
-			// Need to replace the prev/next pointers
-			free_node->size += current_node->size + HEADER_SIZE;
-			free_node->next = current_node->next;
-			free_node->prev = 0;
-		} else {
-			serial_string("Can't combine free_node and start_node\n");
-			// We need to replace the head
-			kernel_heap.start_node = free_node;
-			free_node->next = current_node;
-			free_node->prev = 0;
-			current_node->prev = free_node;
-		}
-
-		serial_string("----End Free----\n");
-		return;
-	}
-
-	// We aren't replacing the head, find the correct position in the list
-	while (current_node->next != 0 && current_node < free_node)
-	{
-		current_node = current_node->next;
-	}
-
-	// Stores the node before free_node and current_node
-	linked_node_t* prev_node = current_node->prev;
-	linked_node_t* middle_node = free_node;
-	linked_node_t* last_node = current_node;
-
-	if (free_node < current_node)
-	{
-		serial_string("free node before tail\n");
-		current_node->prev->next = free_node;
-		free_node->prev = current_node->prev;
-		free_node->next = current_node;
-		current_node->prev = free_node;
-	} else {
-		// TODO we'll never be freeing from behind the tail...
-		serial_string("free node after tail\n");
-		// Check if we ended up at the tail
-		if (current_node->next != 0)
-		{
-			current_node->next->prev = free_node;
-		}
-
-		free_node->next = current_node->next;
-		free_node->prev = current_node;
-		current_node->next = free_node;
-
-		// Used for combinations
-		middle_node = current_node;
-		last_node = free_node;
-	}
-
-	// Check for combinations
-	if (((uint32)prev_node + prev_node->size + HEADER_SIZE) == middle_node)
-	{
-		prev_node->size += middle_node->size + HEADER_SIZE;
-		prev_node->next = middle_node->next;
-		if (middle_node->next == 0)
-		{
-			panic("Next shouldn't be 0!\n");
-		}
-
-		prev_node->next->prev = prev_node;
-
-		middle_node = prev_node;
-	}
-	
-	if (((uint32)middle_node + middle_node->size + HEADER_SIZE) == last_node)
-	{
-		middle_node->size += last_node->size + HEADER_SIZE;
-		middle_node->next = last_node->next;
-		if (last_node->next != 0)
-		{
-			serial_string("Last node was null\n");
-			middle_node->next->prev = middle_node;
-		}
-	}
-
-	serial_string("----End Free----\n");
-}
diff --git a/memory/kmalloc.h b/memory/kmalloc.h
deleted file mode 100644
index 27b7bd7..0000000
--- a/memory/kmalloc.h
+++ /dev/null
@@ -1,13 +0,0 @@
-#ifndef __KMALLOC_H__
-#define __KMALLOC_H__
-
-#include "defs.h"
-
-void __kmem_init_kmalloc();
-
-void __kmem_kmalloc_tests();
-
-void* __kmalloc(uint32 size);
-void __kfree(void *);
-
-#endif
diff --git a/memory/paging.c b/memory/paging.c
deleted file mode 100644
index 36078b7..0000000
--- a/memory/paging.c
+++ /dev/null
@@ -1,140 +0,0 @@
-#include "utils.h"
-#include "paging.h"
-#include "physical.h"
-#include "../serial.h"
-
-// TODO change this to directly link to the already defined page directory
-page_directory_t *__virt_kpage_directory = 0;//&BootPageDirectory;
-
-void __virt_initialize_paging()
-{
-	serial_printf("Boot page dir location: %x\n", &BootPageDirectory);
-	__virt_kpage_directory = (page_directory_t *)__phys_get_free_4k();
-	serial_printf("Page dir location: %x\n", __virt_kpage_directory);
-
-	page_table_t *first_table  = (page_table_t *)__phys_get_free_4k();
-	page_table_t *kernel_table = (page_table_t *)__phys_get_free_4k();
-	serial_printf("First table: %x\n", first_table);
-	serial_printf("Kernel table: %x\n", kernel_table);
-
-	_kmemset(first_table,  0, sizeof(page_table_t));
-	_kmemset(kernel_table, 0, sizeof(page_table_t));
-	
-	// Identity map the lower 1MB of pages
-	uint32 i = 0;
-	uint32 address = 0;
-	for (; i < 256; ++i)
-	{
-		first_table->pages[i].value = address | 3;
-		address += 4096;
-	}
-
-	// Map the kernel
-	//address = KERNEL_LOAD_ADDR;
-	uint32 pages = KERNEL_SIZE / 4096;
-	uint32 page_dir_index = KERNEL_LINK_ADDR / (4096 * 1024);
-	uint32 page_dir_end_index = (KERNEL_LINK_ADDR + KERNEL_SIZE) / (4096 * 1024);
-
-	uint32 page_table_start = (KERNEL_LINK_ADDR >> 12) % 4096;
-	uint32 page_table_end = ((KERNEL_LINK_ADDR + KERNEL_SIZE) >> 12) % 4096;
-
-	serial_printf("Kernel pages: %d\n", pages);
-	serial_printf("Kernel page_dir_index: %d\n", page_dir_index);
-	serial_printf("Kernel end: %d\n", page_dir_end_index);
-	serial_printf("Page table start: %d\n", page_table_start);
-	serial_printf("Page table end: %d\n", page_table_end);
-
-	i = page_table_start;
-	address = KERNEL_LOAD_ADDR;
-	for (; i < page_table_end; ++i)
-	{
-		kernel_table->pages[i].value = address | 3;
-		address += 4096;
-	}
-
-	__virt_kpage_directory->ptables[0] = (uint32)first_table | 3;
-	__virt_kpage_directory->ptables[page_dir_index] = (uint32)kernel_table | 3;
-
-	// Set the last entry to ourself so we can do fancy reading of the page
-	// directory from inside of virtual memory space
-	__virt_kpage_directory->ptables[1023] = (uint32)__virt_kpage_directory | 3;
-
-	__virt_switch_page_directory(__virt_kpage_directory);
-
-	serial_string("4KB page tables enabled\n");
-
-	uint32* data = (uint32 *)__phys_get_free_4k();
-	_kmemset(data, 0, 4096);
-}
-
-void* __virt_get_phys_addr(void *virtual_addr)
-{
-	uint32 page_dir_index = (uint32)virtual_addr >> 22;
-	uint32 page_tbl_index = (uint32)virtual_addr >> 12 & 0x03FF;
-
-	uint32 *pd = (uint32 *)0xFFFFF000;
-
-	// TODO Check whether or not the page directory is present
-	
-
-	uint32 *pt = ((uint32*)0xFFC00000) + (0x400 * page_dir_index);
-	// TODO Here check whether the PT is present
-	
-	return (void *)((pt[page_tbl_index] & ~0xFFF) + ((uint32)virtual_addr & 0xFFF));
-}
-
-void __virt_unmap_page(void *virtual_addr)
-{
-	uint32 page_dir_index = (uint32)virtual_addr >> 22;
-	uint32 page_tbl_index = (uint32)virtual_addr >> 12 & 0x03FF;
-
-	uint32 *pd = (uint32 *)0xFFFFF000;
-	
-	// Here check if the PD entry is present
-	// When it's not present, we're done
-
-	uint32 *pt = ((uint32 *)0xFFC00000) + (0x400 * page_dir_index);
-	// Here need to check whether the PT entry is present
-	// When it is, then we need to unmap it
-
-	pt[page_tbl_index] = 0;
-
-	// TODO check if Page Table is empty, and mark the Page Directory entry
-	// as empty
-
-	// Now you need to flush the entry in the TBL
-	// or you might not notice the change
-}
-
-void __virt_map_page(void *physical_addr, void *virtual_addr, uint32 flags)
-{
-	// Make sure both addresses are page aligned
-	
-	uint32 page_dir_index = (uint32)virtual_addr >> 22;
-	uint32 page_tbl_index = (uint32)virtual_addr >> 12 & 0x03FF;
-
-	uint32 *pd = (uint32 *)0xFFFFF000;
-
-	// TODO Here check if the PD entry is present
-	// When it's not present, create a new empty PT and adjust the PDE accordingly
-	
-	uint32 *pt = ((uint32 *)0xFFC00000) + (0x400 * page_dir_index); 
-	// TODO Here need to check whether the PT entry is present
-	// When it is, then there is already a mapping present, what do you do?
-	
-	pt[page_tbl_index] = ((uint32)physical_addr) | (flags & 0xFFF) | 0x01; // Presnt
-
-	// TODO Now you need to flush the entry in the TBL
-	// or you might not notice the change
-}
-
-void __virt_switch_page_directory(page_directory_t *page_directory)
-{
-	// TODO make this a macro?
-	asm volatile("mov %0, %%cr3" :: "b"(page_directory));
-	// TODO this stuff isn't needed once paging is enabled
-	unsigned int cr0;
-	asm volatile("mov %%cr0, %0": "=b"(cr0));
-	cr0 |= 0x80000000;
-	asm volatile("mov %0, %%cr0":: "r"(cr0));
-}
diff --git a/memory/paging.h b/memory/paging.h
deleted file mode 100644
index 559eb8f..0000000
--- a/memory/paging.h
+++ /dev/null
@@ -1,53 +0,0 @@
-#ifndef __PAGING_H__
-#define __PAGING_H__
-
-#include "defs.h"
-/*
-typedef struct Page
-{
-	uint32 present 		: 1;
-	uint32 read_write 	: 1;
-	uint32 user 		: 1;
-	uint32 accessed 	: 1;
-	uint32 dirty 		: 1;
-	uint32 unused 		: 7;
-	uint32 frame 		: 20;
-} page_t;
-*/
-#define PRESENT 	0x1
-#define READ_WRITE 	0x2
-#define USER 		0x4
-#define WRITE_THRU	0x8
-#define CACHE_DISABLE 0x10
-
-typedef struct Page 
-{
-	uint32 value;
-} page_t;
-
-typedef struct PageTable
-{
-	page_t pages[1024];
-} page_table_t;
-
-typedef union PageDirectory
-{
-	page_table_t *tables[1024];
-	uint32 ptables[1024];
-} page_directory_t;
-
-page_directory_t *__virt_kpage_directory;
-extern page_directory_t BootPageDirectory;
-
-void __virt_initialize_paging(void);
-
-void __virt_switch_page_directory(page_directory_t *page_directory);
-
-// Taken from OS Dev wiki
-void* __virt_get_phys_addr(void *virtual_addr);
-
-// Taken from OS Dev wiki
-void __virt_map_page(void *physical_addr, void *virtual_addr, uint32 flags);
-
-void __virt_unmap_page(void *virtual_addr);
-#endif
diff --git a/memory/physical.c b/memory/physical.c
deleted file mode 100644
index 96713e1..0000000
--- a/memory/physical.c
+++ /dev/null
@@ -1,105 +0,0 @@
-#include "physical.h"
-#include "../serial.h"
-
-uint32 *__phys_bitmap_4k;
-uint32 __phys_bitmap_4k_size;
-
-uint32 KERNEL_SIZE = 0;
-
-void __phys_initialize_bitmap()
-{
-	// Figure out how much physical memory we have	
-	// Memory size in bytes / 4096 byte pages / sizeof(uint32)*8 bits per index
-	__phys_bitmap_4k_size = PHYSICAL_MEM_SIZE / 4096 / (sizeof(uint32)*8);
-
-	// Find the location of the bitmap, make it page aligned, place it right
-	// after the end of the kernel
-	// We need to skip the boot page
-	__phys_bitmap_4k = (uint32*)((((uint32)&KERNEL_END) & 0xFFFFF000) + 0x00001000);
-
-	serial_printf("Kernel end: %x\n", &KERNEL_END);
-	// Set the size of the kernel, include the memory Bitmap
-	// the 0x2000 is the fudge from above
-	//KERNEL_SIZE = ((uint32)&KERNEL_END) - KERNEL_LINK_ADDR + __phys_bitmap_4k_size;
-	KERNEL_SIZE = ((uint32)__phys_bitmap_4k + (uint32)__phys_bitmap_4k_size) - KERNEL_LINK_ADDR;
-	serial_printf("Kernel size: %d\n", KERNEL_SIZE);
-	serial_printf("Bitmap size: %d\n", __phys_bitmap_4k_size);
-	serial_printf("Bitmap location: %x\n", __phys_bitmap_4k);
-	serial_printf("Memory size: %d\n", PHYSICAL_MEM_SIZE);
-	serial_printf("Kernel adjusted end: %x\n", KERNEL_LINK_ADDR + KERNEL_SIZE);
-
-	// Fill the entire bitmap with 1's and then only mark free what we can
-	uint32 i = 0;
-	for (; i < __phys_bitmap_4k_size; ++i)
-	{
-		__phys_bitmap_4k[i] = 0xFFFFFFFF;
-	}
-
-	// TODO, for now just mark everything after the kernel as empty
-	// because the kernel is loaded at the 1MB limit, so mark everything
-	// after as usable/allocatable
-	i = (KERNEL_LOAD_ADDR + KERNEL_SIZE) / 4096 / sizeof(uint32);
-
-	// i = 9.282
-	// Grab those pages that might be free before the next index
-	++i;
-	for (; i < __phys_bitmap_4k_size; ++i)
-	{
-		__phys_bitmap_4k[i] = 0;
-	}
-}
-
-void __phys_set_bit(void* address)
-{
-	// TODO check bounds
-	// address / 4096;
-	uint32 offset = (uint32)address >> 12;
-	uint32 index = offset / sizeof(uint32);
-	__phys_bitmap_4k[index] |= 1 << (offset % (sizeof(int32)*8));
-}
-
-uint32 __phys_check_bit(void* address)
-{
-	// TODO check bounds
-	uint32 offset = (uint32)address >> 12;
-	uint32 index = offset / sizeof(uint32);
-	return __phys_bitmap_4k[index];
-}
-
-void __phys_unset_bit(void* address)
-{
-	// TODO check bounds
-	uint32 offset = (uint32)address >> 12;
-	uint32 index = offset / sizeof(uint32);
-	__phys_bitmap_4k[index] &= ~(1 << (offset % (sizeof(int32)*8)));
-}
-
-void* __phys_get_free_4k()
-{
-	// Skip 32-bits at a time
-	uint32 i = 0;
-	while (__phys_bitmap_4k[i] == 0xFFFFFFFF && i < __phys_bitmap_4k_size) { ++i; }
-
-	// We ran out of physical memory!
-	if (i >= __phys_bitmap_4k_size)
-	{
-		serial_string("No more free pages!\n");
-		for (;;) { asm("hlt"); }
-	}
-
-	// A bit has to be free because this section is != 0xFFFFFFFF
-	uint32 bit = 0x80000000, offset = 0;
-	while ((__phys_bitmap_4k[i] & bit) != 0 && bit != 0)
-	{
-		bit >>= 1;
-		++offset; // Used in address calculation
-	}
-
-	if (bit == 0) { serial_string("Impossible condition!\n"); for (;;) { asm("hlt"); } }
-
-	__phys_bitmap_4k[i] |= bit;
-
-	// (i * sizeof(uint32) + offset) * 4096
-	return (void *)(((i * sizeof(uint32)) + offset) << 12);
-}
-
diff --git a/memory/physical.h b/memory/physical.h
deleted file mode 100644
index 1446a33..0000000
--- a/memory/physical.h
+++ /dev/null
@@ -1,25 +0,0 @@
-#ifndef __PHYSICAL_MEMORY_H__
-#define __PHYSICAL_MEMORY_H__
-
-#define KERNEL_LINK_ADDR 0xC0100000
-//#define KERNEL_LINK_ADDR 0x00100000
-#define KERNEL_LOAD_ADDR 0x00100000
-
-// Assume 256MB of RAM for now
-#define PHYSICAL_MEM_SIZE 256*1024*1024
-
-#include "defs.h"
-
-//////////////////////////////
-extern unsigned int KERNEL_END;
-
-uint32 KERNEL_SIZE;
-
-void __phys_set_bit(void* address);
-void __phys_unset_bit(void* address);
-uint32 __phys_check_bit(void* address);
-void* __phys_get_free_4k();
-
-void __phys_initialize_bitmap();
-
-#endif
diff --git a/memory/utils.c b/memory/utils.c
deleted file mode 100644
index a388514..0000000
--- a/memory/utils.c
+++ /dev/null
@@ -1,43 +0,0 @@
-#include "utils.h"
-
-void _kmemset(void *ptr, unsigned char value, uint32 num)
-{
-	unsigned char *p = (unsigned char *)ptr;
-	while (num > 0)
-	{
-		*p = value;
-		++ptr;
-		--num;
-	}
-}
-
-void _kmemcpy(void *dest, const void *source, uint32 num)
-{
-	unsigned char *d = (unsigned char *)dest;
-	unsigned char *s = (unsigned char *)source;
-	while (num > 0)
-	{
-		*d = *s;
-		++d;
-		++s;
-		--num;
-	}
-}
-
-int32 _kmemcmp(const void *ptr1, const void *ptr2, uint32 num)
-{
-	unsigned char *p1 = (unsigned char *)ptr1;
-	unsigned char *p2 = (unsigned char *)ptr2;
-	while (num > 0)
-	{
-		if (*p1 != *p2)
-		{
-			return *p1 - *p2;	
-		}
-		++p1;
-		++p2;
-		--num;
-	}
-
-	return 0;
-}
diff --git a/memory/utils.h b/memory/utils.h
deleted file mode 100644
index 12c6a95..0000000
--- a/memory/utils.h
+++ /dev/null
@@ -1,10 +0,0 @@
-#ifndef __MEM_UTILS_H__
-#define __MEM_UTILS_H__
-
-#include "defs.h"
-
-void _kmemset(void *ptr, unsigned char value, uint32 num);
-void _kmemcpy(void *dest, const void *source, uint32 num);
-int32 _kmemcmp(const void *ptr1, const void *ptr2, uint32 num);
-
-#endif
diff --git a/startup.S b/startup.S
index 5f87375..5e76475 100644
--- a/startup.S
+++ b/startup.S
@@ -29,16 +29,15 @@
 /* 
  ** SETUP VIRTUAL MEMORY
  */
-KERNEL_VIRTUAL_BASE equ 0xC0000000					; Our kernel is loaded at the 3GB line
-KERNEL_PAGE_NUMBER equ (KERNEL_VIRTUAL_BASE >> 22)	; Page directory in 4MB mode
-
-section .data
-align 4096
-global base_page_directory
-base_page_directory: 	; We use this to identity map the first 1MB
-						; of memory and the kernel at the 3GB line
+#define KERNEL_VIRTUAL_BASE 0xC0000000					/* Our kernel is loaded at the 3GB line */
+#define KERNEL_PAGE_NUMBER (KERNEL_VIRTUAL_BASE >> 22)	/* Page directory in 4MB mode */
 
+#define PAGE_PRESENT 0x1 
+#define PAGE_READ_WRITE 0x2
+#define PAGE_4MB 0x80
 
+.globl boot_page_directory
+boot_page_directory:
 /*
 ** A symbol for locating the beginning of the code.
 */
@@ -57,8 +56,8 @@ _start:
 	movb	$0x00, %al	/* re-enable NMIs (bootstrap */
 	outb	$0x70		/*   turned them off) */
 
-/*
-** Set the data and stack segment registers (code segment register
+	/*
+	 ** Set the data and stack segment registers (code segment register
 ** was set by the long jump that switched us into protected mode).
 */
 	xorl	%eax, %eax	/* clear EAX */
